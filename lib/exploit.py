from pwn import *
from random import randint
from time import sleep
import uuid

local_dir = None
remote_binary = None
local_binary = None
local_libc = None
libc = None
port = None
elf = None

BINARY_PATH = None
CWD = None
LOCAL = None
EXECUTE = True


r"""
    Call this, when you suspect that your exploit works and you should have a shell now.



    Arguments:
            always_recvs: set this to True if you would expect to
                        receive data from process when the exploit fails
            recv_check_timeout: How long to wait for receiving answer from shell.
                                Only makes sense if always_recvs is False

"""
def check_for_shell(io, recv_check_timeout=0.1, always_recvs=False, control_text=b"docgil"):
    try:
        io.sendline(b"echo "+control_text)
        if always_recvs is False:
            if io.can_recv(timeout=recv_check_timeout) is False:
                log.info("cant receive anything after sending shell command -> no shell")
                log.info("maybe try higher recv_check_timeout")
                return False
        r = io.recv()
        log.info("shell check response:")
        log.info(f"{r}")
        if control_text in r:
            log.info("found control text -> shell open")
            return True
        else:
            log.info("did not find control text -> no shell")
            return False
    except EOFError:
        log.info("EOF -> no shell, pipe closed or segfault?")
        return False


def pad(s, slen):
    return s + b"X" * (slen - len(s))


def connect(level, password, init=True):
    global remote_binary
    global local_dir
    global local_binary
    global port
    global libc
    global elf
    global CWD
    global BINARY_PATH
    global LOCAL
    compose_download_paths(level)
    port = 2227
    connected = False
    s = None
    while not connected:
        try:
            s = ssh("utumno" + level, "176.9.9.172", password=password, cache=True, port=port)
            connected = True
            log.info("connected")
            if init:
                s.libs(remote_binary, local_dir)
        except Exception as e:
            log.info("ssh connection attempt failed")
            print("error: {0}".format(e))
            sleep(randint(1, 5))
    load_downloaded_files()
    LOCAL = False
    CWD = "/tmp/gil"+level+"/"
    BINARY_PATH = "/utumno/utumno" + level
    return s


# function of local testing vm
def connect_to_local(level, password, remote=True):
    global CWD
    global LOCAL
    global BINARY_PATH
    global local_dir
    if remote:
        connect(level, password)
    else:
        compose_download_paths(level)
        load_downloaded_files()
    s = ssh("kali", "127.0.0.1", keyfile="/home/kali/.ssh/id_rsa", cache=True)
    CWD = local_dir + "/utumno/"
    BINARY_PATH = CWD + "utumno" + level
    LOCAL = True
    return s


def load_downloaded_files():
    global elf
    global libc
    process(["chmod", "a+x", local_binary])
    elf = ELF(local_binary)
    libc = ELF(local_libc)
    context.clear()
    context.binary = local_binary
    context.log_file = "/tmp/docgillog"


def compose_download_paths(level):
    global remote_binary
    global local_dir
    global local_binary
    global port
    global libc
    global elf
    global local_libc
    local_dir = "/home/kali/PycharmProjects/utumno/" + level
    remote_binary = "/utumno/utumno" + level
    local_binary = local_dir + remote_binary
    local_libc = local_dir + "/lib32/libc.so.6"
    log.info(f"cloned_binary: {local_binary}")


def goto_bash(s, before_func=None, menu_func=None, execute=None):
    done = "0"
    while done == "0":
        if before_func:
            before_func()
        sh = s.process(["sh"])
        if execute:
            sh.sendline(execute)
        sh.interactive()
        done = input("done with sh, done?").replace("\n", "")
        if done == "2":
            menu_func()


def upload(s, content, remote_path):
    log.info("%s " % s.process(["rm", "-rf", remote_path]).recvall())
    temp_path = "/tmp/" + str(uuid.uuid4())
    write(temp_path, content)
    s.upload(temp_path, remote_path)
    rm = process(["rm", "-rf", temp_path])
    log.info("%s " % rm.recvall())

def hex_to_rev_ascii(num):
    hex_num = hex(num)
    ascii = bytes.fromhex(hex_num.replace("0x", "")).decode('utf-8')
    return ascii[::-1]



def append_to_remote_file(s, content, remote_path):
    temp_path = "/tmp/" + str(uuid.uuid4())
    s.download(remote_path, temp_path)
    old = read(temp_path)
    # new = old + b"\n" + content
    new = old + content
    write(temp_path, new)
    s.upload(temp_path, remote_path)
    rm = process(["rm", "-rf", temp_path])
    rm.recvall()


# cut off adr's before and replace many spaces between adrs with one space
# replaces null bytes
def create_memory_snapshot(snapshot, replace_nullbytes=False):
    adrs = b""
    s_adrs = snapshot.replace("\n", " ").split(" ")
    for s_adr in s_adrs:
        if s_adr == "":
            continue
        adr = int(s_adr, 16)
        byte_adr = pack(adr, 32)
        new_byte_adr = b""
        for c in byte_adr:
            if (pack(c, 8) == pack(0, 8)) and replace_nullbytes:
                new_byte_adr += b'\x04'
            else:
                new_byte_adr += pack(c, 8)
        adrs += new_byte_adr
    return adrs
